package main

import "fmt"

/*
死锁并不是锁的一种，而是一种错误使用锁导致的现象，死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。
系统发生死锁现象不仅浪费大量的系统资源，甚至导致整个系统崩溃，带来灾难性后果。所以，对于死锁问题在理论上和技术上都必须予以高度重视。
如果创建了chan，没有 Goroutine 来使用了，则会出现死锁。
使用通道时要考虑的一一个重要因素是死锁。如果Goroutine在一 个通道 上发送数据，那么预计其他的Goroutine应该接收数据。如果这种情况不发生，那么程序将在运行时出现死锁。
类似地，如果Goroutine 正在等待从通道接收数据,那么另一些Goroutine将会在该通道上写入数据，否则程序将会死锁。
存放与取值必须同时存在，并且在不同的goroutine中，才不会造成死锁
单单只有存放，或者只有取值，或者存放与取值都在同一goroutine中，都会造成死锁
*/
//单一goroutine中存放，取值，会造成死锁

// 单线程中，即便往通道中放值，并且从通道中取值，还是会造成死锁
// 存放与取值，必须发生在不同goroutine中才不会造成死锁
func main() {
	ch := make(chan int)
	ch <- 2
	data := <-ch
	fmt.Println(data)
}
